
close all
clear all
restoredefaultpath
cd E:\Dropbox\UTexas\pupilShadow
addpath(genpath(cd))

if ispc
    basePath = 'E:\Dropbox\UTexas\OpticFlowProject';
    cd(basePath);
elseif ismac
    basePath = '/Users/matthis/Dropbox/UTexas/OpticFlowProject';
    cd(basePath);
end

%%Add the folders relevant to the experiment to the path
addpath(genpath(cd))
path = cd;


%% Load the session specific details

spotcheck = false;

sessionID = '2018-01-23_JSM';
% sessionID = '2018-01-26_JAC';
% sessionID = '2018-01-31_JAW';

% condID = 'Woodchips';
condID = 'Rocks';


dataPath = strcat(basePath,'/Data/',sessionID);
shadowPath = strcat(dataPath,filesep,condID,'/Shadow/');
pupilDataPath = strcat(dataPath,filesep, condID,'/Pupil/');


splitWalks_date = datetime;

cd(dataPath)
cd(condID)
cd('OutputFiles')

load(strcat(condID,'.mat'));
%%

    saveOutData = true;
    debug = true;
    spotcheck = true;

    %%
        
        spotcheck = true; %set this to true and the code'll stop at the end of each section
        
        %%
        %%% clip out data relevant to each walk, zeroing and rotating as necessary
        
        clear allWalks
        for ii = 1:length(walks)
            

            ii
            
            thisWalk = [];
            
            %% load various bits of data into struct
            thisWalk.avg_fps = round(mean(diff(syncedUnixTime).^-1));
            thisWalk.shadowMarkerNames = shadowMarkerNames;
            thisWalk.calibDist = calibDist;
            thisWalk.legLength = sesh.legLength;
            thisWalk.vorCalibErr = vorCalibErr;
            
            thisWalk.splitWalks_date = datetime;
            thisWalk.processData_date = processData_date ;
            
            thisWalk.sessionID = sessionID;
            
            %% comXYZ
            thisWalk.comXYZ = comXYZ(walks(ii,1): walks(ii,2),:);
            
            zCom = thisWalk.comXYZ(1, :); %this is the original comXYZ start point, used to zero other data.
            
            thisWalk.comXYZ(:, 1) = thisWalk.comXYZ(:, 1) - zCom(1); %zero X data
            thisWalk.comXYZ(:, 3) = thisWalk.comXYZ(:, 3) - zCom(3); %zero Z data
            
            %these won't change for the other data downstream
            pt0 = thisWalk.comXYZ(end, [1 3]); %original endpoint
            pt1 = [1000 0]; %positive-X vector
            origin = thisWalk.comXYZ(1, [1 3]); %startpoint
            
            
            %the data to be rotated
            X = thisWalk.comXYZ(:,1); %original X
            Z = thisWalk.comXYZ(:,3); %original Z (Y)
            
            disp('rotating COM')
            [x_r, z_r] = rotateFromV0toV1(X, Z, pt0, pt1, origin, debug );
            
            if spotcheck; dbstack; keyboard; end
            thisWalk.comXYZ = [x_r' thisWalk.comXYZ(:,2) z_r'];
            
            %% ground fixations (R)
            thisWalk.rGazeGroundIntersection = rGazeGroundIntersection(walks(ii,1): walks(ii,2),:);
            
            thisWalk.rGazeGroundIntersection(:, 1) = thisWalk.rGazeGroundIntersection(:, 1) - zCom(1); %zero X data
            thisWalk.rGazeGroundIntersection(:, 3) = thisWalk.rGazeGroundIntersection(:, 3) - zCom(3); %zero Z data
            
            X = thisWalk.rGazeGroundIntersection(:,1); %original X
            Z = thisWalk.rGazeGroundIntersection(:,3); %original Z (Y)
            
            disp('rotating rGazeGroundIntersection')
            
            [x_r, z_r] = rotateFromV0toV1(X, Z, pt0, pt1, origin, debug );
            
            if spotcheck; dbstack; keyboard; end
            
            thisWalk.rGazeGroundIntersection = [x_r' thisWalk.rGazeGroundIntersection(:,2) z_r'];
            
             %% ground fixations (L)
            thisWalk.lGazeGroundIntersection = lGazeGroundIntersection(walks(ii,1): walks(ii,2),:);
            
            thisWalk.lGazeGroundIntersection(:, 1) = thisWalk.lGazeGroundIntersection(:, 1) - zCom(1); %zero X data
            thisWalk.lGazeGroundIntersection(:, 3) = thisWalk.lGazeGroundIntersection(:, 3) - zCom(3); %zero Z data
            
            X = thisWalk.lGazeGroundIntersection(:,1); %original X
            Z = thisWalk.lGazeGroundIntersection(:,3); %original Z (Y)
            
            disp('rotating lGazeGroundIntersection')
            
            [x_r, z_r] = rotateFromV0toV1(X, Z, pt0, pt1, origin, debug );
            
            if spotcheck; dbstack; keyboard; end
            
            thisWalk.lGazeGroundIntersection = [x_r' thisWalk.lGazeGroundIntersection(:,2) z_r'];
            
            %% rEyeballCenterXYZ 
            thisWalk.rEyeballCenterXYZ = rEyeballCenterXYZ(walks(ii,1): walks(ii,2),:);
            
            thisWalk.rEyeballCenterXYZ(:, 1) = thisWalk.rEyeballCenterXYZ(:, 1) - zCom(1); %zero X data
            thisWalk.rEyeballCenterXYZ(:, 3) = thisWalk.rEyeballCenterXYZ(:, 3) - zCom(3); %zero Z data
            
            X = thisWalk.rEyeballCenterXYZ(:,1); %original X
            Z = thisWalk.rEyeballCenterXYZ(:,3); %original Z (Y)
            
            disp('rotating rEyeballCenterXYZ')
            
            [x_r, z_r] = rotateFromV0toV1(X, Z, pt0, pt1, origin, debug );
            
            if spotcheck; dbstack; keyboard; end
            
            
            thisWalk.rEyeballCenterXYZ = [x_r' thisWalk.rEyeballCenterXYZ(:,2) z_r'];
            
            %% rEyeballCenterXYZ
            thisWalk.rEyeballCenterXYZ = rEyeballCenterXYZ(walks(ii,1): walks(ii,2),:);
            
            thisWalk.rEyeballCenterXYZ(:, 1) = thisWalk.rEyeballCenterXYZ(:, 1) - zCom(1); %zero X data
            thisWalk.rEyeballCenterXYZ(:, 3) = thisWalk.rEyeballCenterXYZ(:, 3) - zCom(3); %zero Z data
            
            X = thisWalk.rEyeballCenterXYZ(:,1); %original X
            Z = thisWalk.rEyeballCenterXYZ(:,3); %original Z (Y)
            
            disp('rotating rEyeballCenterXYZ')
            
            [x_r, z_r] = rotateFromV0toV1(X, Z, pt0, pt1, origin, debug );
            
            if spotcheck; dbstack; keyboard; end
            
            
            thisWalk.rEyeballCenterXYZ = [x_r' thisWalk.rEyeballCenterXYZ(:,2) z_r'];
            
            %% Image pane (patch) info
            
            
            clear pX_r pZ_r pY
            disp('rotating Patch')
            for pp = 1:5
                
                pX = patchX(pp,walks(ii,1): walks(ii,2));%+thisWalk.camXYZ(:,1)';
                pZ = patchZ(pp,walks(ii,1): walks(ii,2));%+thisWalk.camXYZ(:,3)';
                
                [pX_r(pp,:), pZ_r(pp,:)] = rotateFromV0toV1(pX, pZ, pt0, pt1, origin, debug );
                
                pY(pp,:) = patchY(pp,walks(ii,1): walks(ii,2));%+thisWalk.camXYZ(:,2)';
                
                thisWalk.patchX(pp,:) = pX_r(pp,:)+thisWalk.camXYZ(:,1)';
                thisWalk.patchY(pp,:) = pY(pp,:)+thisWalk.camXYZ(:,2)';
                thisWalk.patchZ(pp,:) = pZ_r(pp,:)+thisWalk.camXYZ(:,3)';
                
            end
            if spotcheck; dbstack; keyboard; end
            
            
            
            %% shadow data
            thisWalk.shadow_ds_fr_mar_dim = shadow_ds_fr_mar_dim(walks(ii,1): walks(ii,2),:,:);
            
            s = thisWalk.shadow_ds_fr_mar_dim;
            
            disp('rotating Marker Data')
            for mm = 1:length(s(1,:,1))
                thisM = squeeze(s(:,mm,:));
                
                thisM(:, 1) = thisM(:, 1) - zCom(1); %zero X data
                thisM(:, 3) = thisM(:, 3) - zCom(3); %zero X data
                
                X = thisM(:,1); %original X
                Z = thisM(:,3); %original Z (Y)
                
                
                [x_r, z_r] = rotateFromV0toV1(X, Z, pt0, pt1, origin, debug );
                hold on
                s(:,mm,:) = [x_r' thisM(:,2) z_r'];
            end
            
            if spotcheck; dbstack; keyboard; end; hold off
            
            thisWalk.shadow_ds_fr_mar_dim = s;
            
            %% gazeXYZ
            thisWalk.gazeXYZ = gazeXYZ(walks(ii,1): walks(ii,2),:);
            
            X = thisWalk.gazeXYZ(:,1); %original X
            Z = thisWalk.gazeXYZ(:,3); %original Z (Y)
            
            disp('rotating gazeXYZ')
            [x_r, z_r] = rotateFromV0toV1(X, Z, pt0, pt1, origin, debug );
            
            if spotcheck; dbstack; keyboard; end
            
            thisWalk.gazeXYZ = [x_r' thisWalk.gazeXYZ(:,2) z_r'];
            
            %% step data
            theseStepIDs = steps_HS_TO_StanceLeg_XYZ(:,1)>=walks(ii,1) & steps_HS_TO_StanceLeg_XYZ(:,1)<=walks(ii,2);
            
            thisWalk.steps_HS_TO_StanceLeg_XYZ = steps_HS_TO_StanceLeg_XYZ(theseStepIDs,:);
            
            
            thisWalk.steps_HS_TO_StanceLeg_XYZ(:, 4) = thisWalk.steps_HS_TO_StanceLeg_XYZ(:, 4) - zCom(1); %zero X data
            thisWalk.steps_HS_TO_StanceLeg_XYZ(:, 6) = thisWalk.steps_HS_TO_StanceLeg_XYZ(:, 6) - zCom(3); %zero Z data
            
            X = thisWalk.steps_HS_TO_StanceLeg_XYZ(:,4); %original X
            Z = thisWalk.steps_HS_TO_StanceLeg_XYZ(:,6); %original Z (Y)
            
            disp('rotating Steps')
            [x_r, z_r] = rotateFromV0toV1(X, Z, pt0, pt1, origin, debug );
            
            if spotcheck; dbstack; keyboard; end
            
            thisWalk.steps_HS_TO_StanceLeg_XYZ(:,[4:6]) = [x_r' thisWalk.steps_HS_TO_StanceLeg_XYZ(:,5) z_r'];
            
            thisWalk.steps_HS_TO_StanceLeg_XYZ(:,1) = thisWalk.steps_HS_TO_StanceLeg_XYZ(:,1) - walks(ii,1);
            thisWalk.steps_HS_TO_StanceLeg_XYZ(:,2) = thisWalk.steps_HS_TO_StanceLeg_XYZ(:,2) - walks(ii,1);
            
            
            %% add non-rotated data
            
            
            thisWalk.porX = porX(walks(ii,1): walks(ii,2),:);
            thisWalk.porY = porY(walks(ii,1): walks(ii,2),:);
            
            thisWalk.frames = walks(ii,1): walks(ii,2);
            thisWalk.etTimeFromZero_ms = etTimeFromZero_ms(walks(ii,1): walks(ii,2));
            thisWalk.etTimes_ms = etTimes_ms(walks(ii,1): walks(ii,2));
            
            thisWalk.takeID = takeID;
            thisWalk.dataPaths = a;
            
            thisWalk.frames_shadow = walks_noDS(ii,1):walks_noDS(ii,2);
            thisWalk.shadowTime = shadowTime(walks_noDS(ii,1):walks_noDS(ii,2));
            
            thisWalk.adjFrames = adjFrames(walks_noDS(ii,1):walks_noDS(ii,2));
            
            thisWalk.chestRawAccXYZ = chestRawAccXYZ(walks_noDS(ii,1):walks_noDS(ii,2),:);
            thisWalk.hipsRawAccXYZ = hipsRawAccXYZ(walks_noDS(ii,1):walks_noDS(ii,2),:);
            thisWalk.headRawAccXYZ = headRawAccXYZ(walks_noDS(ii,1):walks_noDS(ii,2),:);
            thisWalk.lFootRawAccXYZ = lFootRawAccXYZ(walks_noDS(ii,1):walks_noDS(ii,2),:);
            thisWalk.rFootRawAccXYZ = rFootRawAccXYZ(walks_noDS(ii,1):walks_noDS(ii,2),:);
            
            %% correct for alignment error
            
            thisWalk.walks = [1 length(thisWalk.camXYZ)];
            
            [thisWalk] = correctAlignmentError_opt(thisWalk);
            
            
            
            %% load a buncha individual marker datums into the struct
            
            rHeelID = find(strcmp('RightHeel', shadowMarkerNames));
            thisWalk.rHeelXYZ = squeeze(s(:,rHeelID,:)); % pull out rHeelID marker
            
            rToeID = find(strcmp('RightToe', shadowMarkerNames));
            thisWalk.rToeXYZ = squeeze(s(:,rToeID,:)); % pull out rHeelID marker
            
            rFootID = find(strcmp('RightFoot', shadowMarkerNames));
            thisWalk.rFootXYZ = squeeze(s(:,rFootID,:)); % pull out RightFoot marker
            
            
            lHeelID = find(strcmp('LeftHeel', shadowMarkerNames));
            thisWalk.lHeelXYZ = squeeze(s(:,lHeelID,:)); % pull out rHeelID marker
            
            lToeID = find(strcmp('LeftToe', shadowMarkerNames));
            thisWalk.lToeXYZ = squeeze(s(:,lToeID,:)); % pull out rHeelID marker000
            
            lFootID = find(strcmp('LeftFoot', shadowMarkerNames));
            thisWalk.lFootXYZ = squeeze(s(:,lFootID,:)); % pull out LeftFoot marker
            
            
            hTopID = find(strcmp('HeadTop', shadowMarkerNames));
            thisWalk.hTopXYZ= squeeze(s(:,hTopID,:)); % pull out LeftFoot marker
            
            hC1ID = find(strcmp('HeadTop', shadowMarkerNames));
            thisWalk.hC1XYZ= squeeze(s(:,hC1ID,:)); % pull out LeftFoot marker
            
            thisWalk.hCenXYZ = (thisWalk.hTopXYZ + thisWalk.hC1XYZ)/2;
            
            thisWalk.headAngles =headAngles_ds(walks(ii,1): walks(ii,2),:);
            
            
            
            %% get undownsampled data for this walk
            
            %             wStartTime_ET = etTimes_ms(walks(ii,1));
            %             wEndTime_ET = etTimes_ms(walks(ii,2));
            %
            %
            %             [ yy walks_noDS(ii,1)] = min(abs(shadowTime - wStartTime_ET));
            %             [ yy walks_noDS(ii,2)] = min(abs(shadowTime - wEndTime_ET));
            %
            %             thisWalk.walks_noDs = walks_noDS;
            
            %% load undownsampled shadow data
            
            thisWalk.comXYZ_noDS = shadow_fr_mar_dim(walks_noDS(ii,1): walks_noDS(ii,2),1,:);
            
            
            
            zCom_noDS = thisWalk.comXYZ_noDS(1, :); %this is the original comXYZ start point, used to zero other data.
            
            thisWalk.comXYZ_noDS(:, 1) = thisWalk.comXYZ_noDS(:, 1) - zCom_noDS(1); %zero X data
            thisWalk.comXYZ_noDS(:, 3) = thisWalk.comXYZ_noDS(:, 3) - zCom_noDS(3); %zero Z data
            
            %these won't change for the other data downstream
            pt0 = thisWalk.comXYZ_noDS(end, [1 3]); %original endpoint
            pt1 = [1000 0]; %positive-X vector
            origin = thisWalk.comXYZ_noDS(1, [1 3]); %startpoint
            
            
            %the data to be rotated
            X = thisWalk.comXYZ_noDS(:,1); %original X
            Z = thisWalk.comXYZ_noDS(:,3); %original Z (Y)
            
            
            [x_r, z_r] = rotateFromV0toV1(X, Z, pt0, pt1, origin, debug );
            
            thisWalk.comXYZ_noDS = [x_r' thisWalk.comXYZ_noDS(:,2) z_r'];
            
            
            %zero and rotate undownsampled shadow data
            thisShadow_fr_mar_dim = shadow_fr_mar_dim(walks_noDS(ii,1): walks_noDS(ii,2),:,:);
            
            s_noDS = thisShadow_fr_mar_dim;
            
            
            
            
            for mm = 1:length(s_noDS(1,:,1))
                thisM = squeeze(s_noDS(:,mm,:));
                
                thisM(:, 1) = thisM(:, 1) - zCom_noDS(1); %zero X data
                thisM(:, 3) = thisM(:, 3) - zCom_noDS(3); %zero X data
                
                X = thisM(:,1); %original X
                Z = thisM(:,3); %original Z (Y)
                
                
                [x_r, z_r] = rotateFromV0toV1(X, Z, pt0, pt1, origin, debug );
                
                s_noDS(:,mm,:) = [x_r' thisM(:,2) z_r'];
            end
            
            thisWalk.shadow_fr_mar_dim = s_noDS;
            
            
            
            
            
            %zero and rotate RAW undownsampled shadow data
            thisShadow_fr_mar_dim_raw = shadow_fr_mar_dim_raw(walks_noDS(ii,1): walks_noDS(ii,2),:,:);
            
            s_noDS_raw = thisShadow_fr_mar_dim_raw;
            
            zCom_noDS_raw = thisShadow_fr_mar_dim_raw(1,1, :); %this is the original comXYZ start point, used to zero other data.
            
            
            
            for mm = 1:length(s_noDS_raw(1,:,1))
                thisM = squeeze(s_noDS_raw(:,mm,:));
                
                thisM(:, 1) = thisM(:, 1) - zCom_noDS_raw(1); %zero X data
                thisM(:, 3) = thisM(:, 3) - zCom_noDS_raw(3); %zero X data
                
                X = thisM(:,1); %original X
                Z = thisM(:,3); %original Z (Y)
                
                
                [x_r, z_r] = rotateFromV0toV1(X, Z, pt0, pt1, origin, debug );
                
                s_noDS_raw(:,mm,:) = [x_r' thisM(:,2) z_r'];
            end
            
            thisWalk.shadow_fr_mar_dim_raw = s_noDS_raw;
            
            
            
            
            
            thisWalk.rHeelXYZ_noDS = squeeze(s_noDS(:,rHeelID,:)); % pull out rHeelID marker
            
            thisWalk.rToeXYZ_noDS = squeeze(s_noDS(:,rToeID,:)); % pull out rHeelID marker
            
            thisWalk.rFootXYZ_noDS = squeeze(s_noDS(:,rFootID,:)); % pull out RightFoot marker
            
            
            thisWalk.lHeelXYZ_noDS = squeeze(s_noDS(:,lHeelID,:)); % pull out rHeelID marker
            
            thisWalk.lToeXYZ_noDS = squeeze(s_noDS(:,lToeID,:)); % pull out rHeelID marker000
            
            thisWalk.lFootXYZ_noDS = squeeze(s_noDS(:,lFootID,:)); % pull out LeftFoot marker
            
            
            thisWalk.hTopXYZ_noDS = squeeze(s_noDS(:,hTopID,:)); % pull out LeftFoot marker
            
            thisWalk.hC1XYZ_noDS = squeeze(s_noDS(:,hC1ID,:)); % pull out LeftFoot marker
            
            thisWalk.hCenXYZ_noDS = (thisWalk.hTopXYZ_noDS + thisWalk.hC1XYZ_noDS)/2;
            
            thisWalk.headAngles_noDS =headAngles(walks_noDS(ii,1): walks_noDS(ii,2),:);
            
            
            
            
            
            %% undownsampled step ID's
            
            if ~strcmp(condID, 'frisbee')
                theseStepIDs_noDS = steps_HS_TO_StanceLeg_XYZ_noDS(:,1)>=walks_noDS(ii,1) & steps_HS_TO_StanceLeg_XYZ_noDS(:,1)<=walks_noDS(ii,2);
                
                thisWalk.steps_HS_TO_StanceLeg_XYZ_noDS = steps_HS_TO_StanceLeg_XYZ_noDS(theseStepIDs_noDS,:);
                
                
                thisWalk.steps_HS_TO_StanceLeg_XYZ_noDS(:, 4) = thisWalk.steps_HS_TO_StanceLeg_XYZ_noDS(:, 4) - zCom_noDS(1); %zero X data
                thisWalk.steps_HS_TO_StanceLeg_XYZ_noDS(:, 6) = thisWalk.steps_HS_TO_StanceLeg_XYZ_noDS(:, 6) - zCom_noDS(3); %zero Z data
                
                X = thisWalk.steps_HS_TO_StanceLeg_XYZ_noDS(:,4); %original X
                Z = thisWalk.steps_HS_TO_StanceLeg_XYZ_noDS(:,6); %original Z (Y)
                
                
                [x_r, z_r] = rotateFromV0toV1(X, Z, pt0, pt1, origin, debug );
                
                thisWalk.steps_HS_TO_StanceLeg_XYZ_noDS(:,[4:6]) = [x_r' thisWalk.steps_HS_TO_StanceLeg_XYZ_noDS(:,5) z_r'];
                
                thisWalk.steps_HS_TO_StanceLeg_XYZ_noDS(:,1) = thisWalk.steps_HS_TO_StanceLeg_XYZ_noDS(:,1) - walks_noDS(ii,1);
                thisWalk.steps_HS_TO_StanceLeg_XYZ_noDS(:,2) = thisWalk.steps_HS_TO_StanceLeg_XYZ_noDS(:,2) - walks_noDS(ii,1);
                
                
            end
            
            
            
            
            
            %%
            allWalks{ii} = thisWalk;
            
            figure(condIter*1000+sub)
            
            if mod(ii,2); %% plot even/odd walks on differnet subplots (because even plots are rotated 180 from odd ones)
                subplot(311);
            else
                subplot(312)
            end
            
            plot(thisWalk.comXYZ(:,1), thisWalk.comXYZ(:,3))
            
            hold on
            plot(thisWalk.groundFixations(:,1), thisWalk.groundFixations(:,3),'.')
            
            plot(thisWalk.comXYZ(1,1), thisWalk.comXYZ(1,3),'gp')
            plot(thisWalk.comXYZ(end,1), thisWalk.comXYZ(end,3),'rp')
            plot(thisWalk.steps_HS_TO_StanceLeg_XYZ(:,4), thisWalk.steps_HS_TO_StanceLeg_XYZ(:,6),'o')
            
            plot(thisWalk.steps_HS_TO_StanceLeg_XYZ(1,4), thisWalk.steps_HS_TO_StanceLeg_XYZ(1,6),'go')
            plot(thisWalk.steps_HS_TO_StanceLeg_XYZ(end,4), thisWalk.steps_HS_TO_StanceLeg_XYZ(end,6),'ro')
            
            axis equal
            
            if mod(ii,2);
                title(strcat(condID,' - odd walks'))
            else
                title(strcat(condID,' - even walks'))
            end
            
            title(condID)
            
            subplot(313)
            plot(comXYZ)
            hold on
            plot(walks(ii,1):walks(ii,2), comXYZ(walks(ii,1):walks(ii,2),3),'o')
            drawnow
            beep
            
            %%
            
        end
        
        
        
        
        
        
        
        
        
        
        
        %%
        if saveOutData
            switch condIter
                case 1
                    frisbee = allWalks;
                    save('allWalks.mat','frisbee')
                    
                case 2
                    
                    flat = allWalks;
                    save('allWalks.mat','flat','-append')
                case 3
                    
                    medium = allWalks;
                    save('allWalks.mat','medium','-append')
                case 4

                    rough = allWalks;
                    save('allWalks.mat','rough','-append')
            end
        end
        
